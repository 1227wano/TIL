- 진법변환
    - 10진수를 2진수로 변환
        
        ```python
        def decimal_to_binary(n):
        		binary_num = ''
        		
        		if n == 0:
        				return '0'
        		
        		# 0보다 클때까지 2로 나누면서 나머지를 정답에 추가
        		while n > 0:
        				remain = n % 2
        				binary_num = str(remain) + binary_num
        				n = n // 2
        		
        		return binary_num
        ```
        
    
    - 10진수를 16진수로 변환
        
        ```python
        def decimal_to_hexadecimal(n):
        		hex_digits = '0123456789ABCDEF'
        		hexadecimal_num = ''
        		
        		if n == 0:
        				return '0'
        		
        		# 0보다 클때까지 2로 나누면서 나머지를 정답에 추가
        		while n > 0:
        				remain = n % 16
        				# 10-15 를 A-B로
        				hexadecimal_num = hex_digits[remain] + hexadecimal_num
        				n = n // 16
        		
        		return hexadecimal_num
        ```
        
    
    → 조회를 할때는 문자열이 빠름
    
    → 변화가 있을 것이라면 리스트나 딕셔너리
    
    - 2진수를 10진수로 변환
    
    ![image.png](attachment:a8a8b25a-cfab-4e56-8579-26133eb40d65:image.png)
    
    ```python
    def binary_decimal(n):
    		decimal_num = 0
    		pow = 0
    		
    		for digit in reversed(binary_str):
    				if digit == '1':
    						decimal_num += 2 ** pow
    				pow += 1
    		
    		return decimal_num
    ```
    
    - 16진수와 2진수로 변환
    
    ![image.png](attachment:f1777f75-75aa-472f-8c80-341cca50e6d2:image.png)
    
    ![image.png](attachment:aedf7008-14be-4248-ac71-99973d6e96b5:image.png)
    
    or
    
    ![image.png](attachment:7abe1d45-d515-420b-9dc9-4ac0a0a3ac2c:image.png)
    

- 비트 연산
    
    : 컴퓨터의 CPU 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셉 등을 계산
    
    1 bit = 0, 1
    
    1 byte = 8-bit
    
    - AND와 OR 비트연산자 이해하기
        - a AND b ( & ) : a, b 둘 다 1일 때만 결과가 1, 그 외에는 0
        - a OR b ( | ) : a, b 둘 중 하나만 1이면 결과가 1, 그 외에는 0
    - XOR와 NOT 연산자
        - XOR ( ^ ) : 어떤 값이던 특정 수로 2회 XOR를 하면 원래 수로 돌아옴
    
    - 비트연산자
        - Left Shift << : 특정 수 만큼 비트를 왼쪽으로 밀어냄
        - Right Shift << : 특정 수 만큼 비트를 오른쪽으로 밀어냄 (우측 비트들이 제거됨)
            
            ex) 
            1  <<  4  = 16   ⇒ 1 → 10000(2진수) = 16
            7  >>  1  = 3    ⇒  0111 → 11(2진수) = 3
            
        
        1. 부분집합의 수를 바로 구할 수 잇다
            
            arr = [1,2,3,4]  # 부분집합은 16개
            
            부분집합 = 1 << len(arr)
            
        
        1. 전체 부분 집합을 구할 수 있다.
            
            ```python
            for i in range(1 << len(arr)):
            		for idx in range(len(arr)):
            				if i $ (1 << idx):
            						print(arr[idx], end=' ')
            		print()
            ```
            
        
        1. 응용. 합이 10인 부분집합만 구해
            
            ```python
            arr = [1,2,3,4,5,6]
            for i in range(1 << len(arr)):
            		subset = []
            		total = 0
            		
            		for idx in range(len(arr)):
            				if i $ (1 << idx):
            						subset.append(arr[idx])
            						total += arr[idx]
            		
            		if total == 10:
            						print(subset)
            ```
            
    
    - 음수 표현 방법
        - 컴터는 음수를 ‘2의 보수’로 관리함
        - 맨 앞자리 bit(MSB)는 음수 or 양수를 구분하는 비트
        - 2의 보수 예시
            
            10001 의 2의 보수  →   수를 모두 뒤집고 +1 ⇒ 01110 + 1 = 01111 (이걸 다시 하면 10001이 됨)
            
            - -5를 2의 보수로 표현하는 방법 ( 수를 8-bit로 저장하는 경우 )
            - 수 5를 진수로 나타내면 0000 0101 (7-bit)
            - -5 는 음수이기에 MSB는 1
            - 나머지 7-bit에 대해 수를 뒤집고 1을 더함(2의 보수)
            - 수 5를 뒤집으면 111 1010이며 1을 더하면 111 1011
            - 따라서 1111 1011 이 됨
    
    - 비트 연산은 어케 활용될까?
        - 조건문 구현 → 매우 짧아짐
        - (효율적인) 비트 연산
- 실수
    - 소수점 출력 방법 : n.2f → n값을 소수점 셋째자리에서 반올림
    - 실수 표현 범위
        
        최대는 1.8 x 10^308 이고 그 이상은 inf로 표현
        
        최소는 약 5.0 x 10^-324 이며 이 이하는 0으로 표현
        
    - 컴터는 실수를 내부적으로 근사값으로 저장
    ex) 0.1 + 0.1 + 0.1 == 0.3 [False]
    
- 정리
    1. 진법 ( 우리가 쓰는 표현들을 컴터의 표현으로 )
    2. 컴터의 계산 ( 비트 연산 )
        - 상태값 관리
        - 부분 집합
    3. 실수
        
        : 컴터의 연산을 이해해보기