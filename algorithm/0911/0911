0911 백트래킹

- 백트래킹
    - N-Queen 문제
        - 퀸들이 서로 위협하지 않도록 n개의 퀸을 배치하는 문제퀸을 배치
        - 퀸을 배치한 n개의 위치는?
        
        백트래킹 개념
        
        - 여러가지 선택지들이 존재하는 상황에서 한 가지 선택
        - 선택이 이뤄지면 새로운 선택지들의 집합이 생성됨
        - 올바른 선택을 반복하며 최종 상태(goal state)로
        
        백트래킹과 dfs의 차이
        
        - 어떤 노드에서 출발하는 경로가 해결책으로 이어질것같지 않으면 더이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임 → 🍆치기!
        - 즉 DFS는 모든 경로를 다 탐색하는데, 백트래킹은 불필요한 경로를 조기에 차단
        - DFS하기에 경우의 수가 많은 경우 백트래킹을 사용하여 일반적으로 경우의 수가 줄어들지만, 이 역시 최악의 경우 지수함숙시간을 요하므로 처리 불가능함
        
        ![image.png](attachment:be761526-51fb-4d25-8fe1-302171ac72d4:image.png)
        
        - N-Queen 코드
            
            ```python
            # N-Queen
            def check(row, col):
                # (row, col) 좌표 기준
                # 1. 같은 열에 놓은 적이 잇는가
                for i in range(row):
                    if visited[i][col]:
                        return False
            
                # 2. 좌상단 대각선에 놓은 적이 있는가 (\)
                i, j = row-1, col-1
                while i >= 0 and j >= 0:
                    if visited[i][j]:
                        return False
            
                    i -= 1
                    j -= 1
            
                # [참고] for문으로 하고싶다
                # for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):
                #     if visited[i][j]:
                #         return False
                # zip이 머더라...
            
                # 3. 상단 대각선에 놓은 적이 있는가 (/)
                i, j = row-1, col+1
                while i >= 0 and j < N:
                    if visited[i][j]:
                        return False
            
                    i -= 1
                    j += 1
            
                return True
            
            # 종료조건 : N개의 행을 모두 고려하면 종료
            # 가지의 수 : N개의 열
            def recur(row):
                global answer
            
                if row == N:
                    answer += 1
                    return
            
                for col in range(N):
                    # 가지치기 : 같은 열을 못고르도록
                    # --> 유망하지 않은 케이스를 모두 삭제(세로, 대각선)
                    if not check(row, col):
                        continue
            
                    # col을 선택
                    visited[row][col] = 1
                    recur(row+1)
                    visited[row][col] = 0
            
            N = 8
            answer = 0  # 가능한 정답수
            visited = [[0] * N for _ in range(N)]
            recur(0)
            print(f'N={N} / answer={answer}')
            ```
            
    
- 트리
    
    
    - 트리는 사이클이 없는 무향 연결 그래프
        - 두 노드 사이에는 유일한 경로가 존재
        - 각 노드는 최대 하나의 부모 노드가 존재 가능
        - 각 노드는 자식 노드가 없거나 하나 이상 존재 가능
    
    ![image.png](attachment:81592b50-3eed-4184-9e44-c616e6d7f157:image.png)
    
    - 비선형구조
        - 원소들 간에 1:n 관계를 가지는 자료구조
        - 원소들 간에 계층 관계를 가지는 계층형 자료구조
    
    - 트리용어
        - 노드의 차수 : 노드에 연결된 자식 노드의 수
        - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
        - 노드의 높이 : 루트에서 노드에 이르는 간선의 수, 노드의 레벨
        - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨
    
    - 이진 트리
        - 모든 노드들이 최대 2개의 서브트리를 갖음
        - 레벨 i에서의 노드의 최대 개수는 2^i개
        - 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며, 
        최대 개수는 (2^(2+1)-1)개
    
    - 포화 이진트리 : 
    모든 레벨에 노드가 포화상태로 차있는 이진트리
    
    ![image.png](attachment:8a116ac5-53cc-4da2-ab1a-cf7fbaa81628:image.png)
    
    - 완전 이진트리 : 
    높이가 h이고 노드 수가 n개 일때 포화 이진 트리의 노드번호 1번부터 n번까지 빈 자리가 없는 이진트리
    
    ![image.png](attachment:cdc98879-0083-4607-8039-4d61d72f711f:image.png)
    
    - 노드 번호의 성질
        - 노드 번호가 i인 노드의 부모 노드 번호 → i//2
        - 노드 번호가 i인 노드의 왼쪽 자식 노드 번호 → 2*i
        - 노드 번호가 i인 노드의 오른쪽 자식 노드 번호 → 2*i+1
        - 레벨 n의 노드 시작 번호 → 2^n
        
    - 배열을 이용한 이진 트리의 표현의 단점
        - 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생
        - 트리 중간에 새 노드를 삽입하거나 기존 노드를 삭제할 경우 배열의 크기 변경 어려워 비효율적
    
    - 연결리스트를 이용한 이진 트리의 표현
        - 노드리스트[노드번호] = 노드 같은 식으로 2차원 배열을 만들어감
        - → 이를 1차원으로 한다면?
    
    - 연습 문제
        - 이진 탐색 트리
            
            : 작으면 왼쪽 자식, 크면 오른쪽 자식
            
            - 삽입연산
            
            ![image.png](attachment:60400e60-6d4b-4838-8858-6400b5291b19:image.png)
            
            - 삭제연산
            
            ![image.png](attachment:99b12720-49fa-434a-bb88-ad4a99b9a825:998292da-b88f-4dd4-82ab-c450f8eb8e40.png)
            
            - 이진탐색트리의 성능
                - 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸림
                - 평균 : O(log n)
                - 최악 : O(n)
            
        - 힙 ( 우선순위 큐 )
            
            : 완전 이진트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위함
            
            - 최대 힙 : 키 값이 가장 큰 노드를 찾기 위한 힙, 루트 노드는 키 값이 가장 큼
            - 최소 힙 : 키 값이 가장 작은 노드를 찾기 위한 힙, 루트 노드는 키 값이 가장 작음
            - 조건 : 완전 이진 트리여야 함, 최대나 최소의 규칙대로 노드가 주어질 것
            
            heapq 라이브러리를 import 하기~
            
            - heapq.heappush()
            - heapq.pop()
            - but, MIN heap이 기본이기 때문에, MAX heap으로 하려면 음수를 곱함
            
            sort() 쓰면 되는데 왜 heap을 쓰나?
            
            → 데이터의 삽입/삭제가 빈번한 경우
            
            sort() : 삽입 삭제 할때마다 O(NlogN)
            
            heap() : O(logN) 만에 삽입삭제해도 정렬된 구조를 유지