- Stack 계산기
    
    후위  표기법 변환
    
    - 중위 표기법(A + B)의 수식을 후위 표기법으로 변경(stack 이용)
    - 후위 표기법의 수식(AB+)을 stack을 이용하여 계산
    
    변환 방법 1
    
    1. ( (A*B) - (C/D) )
    2. ( (AB)* (CD)/ ) -
    3. AB*CD/-
    
    변환 방법 2
    
    1. 입력받은 중위표기법에서 토큰을 읽는다
    2. 토큰이 피연산자면 토큰 출력
    3. 토큰이 연산자일때
        1. 스택의 top에 저장돼있는 연산자보다 우선순위가 높으면 스택에 push
        2. 아니면 스택 top의 연산자의 우선순위가 토큰의 우선순위보다 작을때까지 스택에서 pop한후 토큰의 연산자를 push. 만약 top에 연산자가 없으면 push
    4. 토큰이 ‘)’면 스택 top에 ‘(’가 올때까지 스택에 pop연산을 수행하고 그 연산자를 출력. ‘(’를 만나면 pop만 하고 출력안함
    5. 중위표기법에 더 읽을것이 없다면 중지, 있다면 1부터 재반복
    6. 스택에 남아있는 연산자를 모두 pop하여 출력
        1. 스택 밖의 ‘(’는 우선순위가 가장 높으며, 스택 안의 ‘(’는 우선순위가 가장 낮다
    
    - 우선순위 : 
    icp(in-coming priority)
    isp(in-stack priority)
    if ( icp > isp) push() else pop()
    ( 표의 숫자는 우선순위 )
    
    ![image.png](attachment:a0ff1ed8-d7f9-41a1-b348-553f724b7ca0:image.png)
    
    ```python
    # (6+5*(2-8)/2) 를 6528-*2/+ 로
    
    stack = [0] * 100
    top = -1
    
    icp = {'(':3, '*':2, '/':2, '+';1, '-':1}  # 밖에 있을때의 우선 순위 (클수록 높음)
    isp = {'(':0, '*':2, '/':2, '+';1, '-':1}  # 스택 안에서의 우선 순위 ( " )
    
    infix = '(6+5*(2-8)/2)'
    postfix = ''
    
    for token in infix:
    		if token not in '(+-/)'  # 피연산자면 후위식에 추가
    				fostfix += token
    		elif token == ')':       # 여는 괄호를 만날때까지 pop()
    				 while top > -1 and stack[top] != '(':
    						 top += 1
    						 postfix += stack[top+1]
    					if top != -1:  # 전체 수식이 괄호로 둘러 쌓이지 않은 경우 대비
    							top -= 1   # '(' 버림..
    		else:      # 연산자의 경우
    				if top == -1 or isp[stack[top]] < icp[token]:
    						top += 1     # push
    						stack[top] = token
    				elif isp[stack[top]] >= icp[token]:
    						while top > -1 and isp[stack[top]] >= icp[token]:
    								postfix += stack[top]
    								top -= 1
    						top += 1    # push
    						stack[top] = token
    ```
    
    후위 표기법 연산
    
    1. 피연산자 만나면 스택에 push
    2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산, 결과를 다시 스택에 push
    3. 수식 끝나면 마지막으로 스택을 pop하여 출력
    
    주의! 피연산자를 꺼낼때 먼저 꺼낼것을 수식 오른쪽에 보내야함!
    
    ![image.png](attachment:e8ac953d-8036-4d5a-8239-c3d40eaeb33a:image.png)
    
    ![image.png](attachment:11ca8507-1ec6-4ba3-abfc-c46987f8d9a3:image.png)
    
- Stack 응용
    
    백트래킹 : 후보해를 구성해나가다가 더이상 해가 될수없다고 판단되면 되돌아가서 다른 경로를 시도함
    
    - 탐색 알고리즘 중 하나
    - 가능성이 없는 경로를 탐색 중지하고 되돌아가며 해결책 찾음
    - 최적화(optimization) 문제와 결정(decision) 문제에 적용
    - 적용 예
        - N-Queens 문제
        - 미로 찾기
        - 순열/조합 생성
        - 부분집합 생성
        - 스도쿠 풀이 등
    
    백트래킹과 DFS의 차이
    
    - Prunning (가지치기) 유무
    : 백트래킹은 어떤 node에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않고 시도를 줄임
    - 조기 경로 차단
    : DFS는 모든 경로를 추적하지만, 백트래킹은 불필요한 경로를 조기에 차단
    - 경우의 수가 많은 경우
    : 예를 들어 N!인 경우의 수를 가진 문제에 대해 DFS를 가하면 처리가 불가능
    백트래킹을 적용하면 일반적으로 경우수가 줄지만 최악의 경우 지수함수시간을 요하므로 처리불가
    
    백트래킹 기법
    
    - 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 이동
    - 어떤 노드를 방문시, 그 노드를 포함한 경로가 해가 될수없으면 그 노드는 유망하지 않다고 하며 반대로 해의 가능성이 있으면 유망하다고 판단
    - 가지치기 : 유망하지 않는 노드가 포함되는 경로는 더이상 고려하지 않음
    
    ![image.png](attachment:82b53ec4-ec10-4a0c-ac8c-eabf7d10ebf2:image.png)
    
    유망 점검 방법
    
    f (i, j) ← 현재 노드
    
    if (i, j) 가 목표지점?
    
    else: 후보 찾기   [→, ↓]
    
    for 후보별 방문 (→, ↓)
    

오늘의 정리

1. 중위표기식 → 후위표기식 이 어려우면 코드제공한거 이해하기~
2. 후위표기식 → 연산  해야지
3. 백트래킹 은 이런거구나~ 하기 ← A형 목표라면 해야지

```python
# maze
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().strip())) for _ in range(N)]
    result = 0

    # 시작점 찾기
    si = sj = 0
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 2:
                si, sj = i, j
                break

    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]   # 상하좌우
    visited = [[False] * N for _ in range(N)]

    def dfs(si, sj):
        stack = [(si, sj)]      # 첫방문지 & 다음방문지 저장
        visited[si][sj] = True  # 방문여부

        while stack:            # 스택에 가능방문지 저장하고
            i, j = stack.pop()  # 빼면서 첫 방문지까지 빠지면 반복끝

            if arr[i][j] == 3:  # 도착점
                return 1

            for di, dj in dirs:     # 인접 가능방문지 찾고
                ni, nj = i + di, j + dj
                if 0 <= ni < N and 0 <= nj < N:
                    if not visited[ni][nj] and arr[ni][nj] != 1:  # 방문 안했고, 벽이 아닌곳이면
                        visited[ni][nj] = True                    # push 시점에 방문 처리
                        stack.append((ni, nj))
        return 0

    result = dfs(si, sj)
    print(f'#{tc} {result}')

```