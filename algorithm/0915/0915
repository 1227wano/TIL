0915 그래프 1

- 그래프
    
    : 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현
    
    → 선형, 트리 자료구조로 표현하기 어려운 N : N 관계를 가지는 원소들을 표현하기 용이
    
    = 그래프는 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료구조
    
    |V| : 정점의 개수 |E| : 그래프에 포함된 간선의 개수
    
    라고 할때,
    
    |V|개의 정점을 가지는 그래프는 최대  |E| = |V|*(|V|-1)/2 개의 간선을 가질 수 있다
    
    그래프 유형
    
    - 무향 그래프
    
    - 유향 그래프
    
    - 가중치 그래프
    
    ![image.png](attachment:71ce7322-ace9-40ad-8e6d-571c2c7ad242:image.png)
    
    ![image.png](attachment:46cf8a31-1aaa-483b-8414-1fb92d601e35:image.png)
    
    ![image.png](attachment:76090a41-d2b9-4a71-a016-7a7a0a6f6bb7:image.png)
    
    - 사이클 없는 방향 그래프
    
    ![image.png](attachment:bec6140a-51b6-4e34-91cc-483c3fb71153:image.png)
    
    - 완전 그래프 : 정점들에 대해 가능한 모든 간선들을 가진 그래프
    - 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
    
    ![image.png](attachment:000ca554-3dd3-409f-8d49-accda1011bd7:image.png)
    
    - 인접 정점
        - 두 개의 정점에 간선이 존재하면 서로 인접이라함
        - 완전 그래프에 속한 임의의 두 정점들은 모두 인접임
        
    - 그래프 경로
        - 최대 한번만 지나는 경로를 단순경로
        - 시작한 정점에서 끝나는 경로를 사이클
    
    - 인접 행렬
        
        : 두 정점을 연결하는 간선의 유무를 행렬로 표현
        
        → 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
        
        - 무향 그래프 ( i번째 행의 합 = i번째 열의 합 = Vi의 차수)
        
        ![image.png](attachment:4b2675fa-921c-4133-aa1e-146249fe5e04:image.png)
        
        - 유향 그래프 ( 행 i의 합 = Vi의 진출 차수, 열 i의 합 = Vi의 진입 차수 )
        
        ![image.png](attachment:2b0ba4a9-0ce7-4750-a72d-4832699a39c2:image.png)
        
        - 장점 : 쉽고, 특정 연결 검색이 빠름
        - 단점 : 메모리 낭비가 많다
    
    - 인접 리스트 ( 인접 행렬의 단점을 보완 )
        
        : 각 정점에 대한 인접 정점들을 순차적으로 표현 (→ 연결 안된건 다 버림 )
        
        - 장점 : 메모리 효율적
        - 단점 : 특정 연결 정보 조회 느리다
        
        ![image.png](attachment:2c8a6130-ff23-434c-9d75-02d6b1346ce2:image.png)
        
    
- DFS
    
    모든 정점을 중복없이 빠짐없이 방문
    
    - 재귀
        - G : 탐색할 그래프
        - v : 방문하는 정점
        
        ![image.png](attachment:12370565-4272-4753-90a9-90346282798e:image.png)
        
    
    - 반복
        
        ![image.png](attachment:6f5d9fab-9d67-4ba3-8e40-3885fec98bbc:image.png)
        
        → stack 과 재귀호출로 구현
        
        - 재귀 ( 코테용으로 추천 )
            - 장점 : 구현이 쉽다
            - 단점 : 느리다 + 재귀 깊이 제한
        - stack
            - 장점 : 빠르다
            - 단점 : 구현이 어렵다
    
- BFS
    - queue 를 활용하는데, 중복이 발생하지 않으려면, queue에 추가할때 visited 체크를 해야함
    
    - 둘다 완탐인데, DFS와의 차이는?
        - DFS
            - 경로를 출력
            - 갈 수 있는 경로의 수
        - BFS
            - 몇 번 만에 가는지?
            - 최단 거리?
        - ex) 지하철 노선도
            - → 환승해서 가는 최단 거리는 BFS!
    
- Union-Find(Disjoint set, 서로소 집합)
    - 공통 원소가 없는 집합 : 교집합이 없음
    - 대표자 : 각 집합을 대표하는 하나의 원소를 말함
    - 상호 배타 집합
        - 확률, 논리, 집합론에서 동시에 일어날수없는 경우, 공통이 없는 경우를 말함
        - 집합론에서는 서로 소와 같은 뜻으로 사용됨
    - 표현 방법
        - 연결리스트(인접리스트 아님)나 트리를 이용해 표현
    
    - 서로 소 집합 연산
        - Make-Set(x) : x를 원소로 가진 집합을 만듦
        - Find-Set(x) : x가 속산 집합의 대표 원소를 반환
        - Union(x,y) : y가 속한 집합과 x가 속한 집합의 합집합을 만듦(x가 합집합의 대표원소로)
    
    - 상호 배타 집합 표현 - 트리
        - 하나의 집합을 하나의 트리로 표현
        - 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 됨
        - 문제점 : 편향 트리가 되는 경우, Find_Set()할때마다 시간 오래 걸림
            
            → Find_Set()에서 찾아진 대표 원소로 각 원소의 대표원소를 바꾸면 경로가 단축됨
            
    
    - 연산의 효율 높이는 법
        
        Rank를 이용한 Union
        
        1. 각 노드는 자신을 루트로 하는 subtree의 높이를 Rank라는 이름으로 저장
        2. 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙임
        
    
    ⇒ 그래프의 사이클 탐지시, 다른 알고리즘 + Union_find 의 형태로 활용