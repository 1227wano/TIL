- 부분집합
    - Backtracking로 powerset 만들기
        
        ```python
        def backtrack(a, k, n):
            """
            a: 현재까지의 해(배열)
            k: 현재 단계 (결정할 원소의 인덱스)
            n: 전체 원소 개수
            """
            c = [0] * MAXCANDIDATES   # 후보군 배열
        
            if k == n:  # 해를 다 만들었을 경우
                process_solution(a, k)   # 원하는 작업 실행
            else:
                ncandidates = construct_candidates(a, k, n, c)
                for i in range(ncandidates):
                    a[k] = c[i]
                    backtrack(a, k + 1, n)
                    
        def construct_candidates(a, k, n, c):
            c[0] = True   # 현재 원소 포함
            c[1] = False  # 현재 원소 미포함
            return 2      # 후보 개수 (True/False)
        
        def process_solution(a, k):
            # a[i] == True 인 원소만 출력
            for i in range(k):
                if a[i]:
                    print(num[i], end=' ')
            print()
        MAXCANDIDATES = 2
        NMAX = 4
        a = [0] * NMAX
        num = [1,2,3,4]
        backtrack(a, 0, 3)
        ```
        
    - 순열1
        
        
        ![image.png](attachment:61d018c7-ca46-4d95-a5e5-9ec0a5c4942a:image.png)
        
        - 순열2
            
            ```python
            def f(i, N):    # 크기가 N이고 순열을 저장한 p배열에서 p[i]를 결정하는 함수
                if i == N:  #
                    print(p)
                else:
                    for j in range(i, N):
                        p[i], p[j] = p[j], p[i]
                        f(i+1, N)   # i+1자리 결정
                        p[i], p[j] = p[j], p[i]
            
            p = [0,1,2]
            N = 3
            f(0, N)
            ```
            
        - DFS와 백트래킹의 차이
            
            
            | 구분 | DFS | 백트래킹 |
            | --- | --- | --- |
            | 목적 | 모든 경로/노드 탐색 | 조건 만족하는 해 탐색 |
            | 가지치기 | 안 함 | 함 (조건 만족 못하면 중단) |
            | 활용 | 그래프 탐색, 경로 찾기 | 제약 문제 해결 (N-Queens, 순열/조합 등) |
            | 효율성 | 경우에 따라 비효율적 | 탐색 공간 줄여 효율적 |
            
            ## ✅ DFS (Depth-First Search)
            
            - **정의**: 그래프나 트리에서 한 경로를 끝까지 파고들어간 후, 막히면 다시 돌아와 다른 경로를 탐색하는 방법.
            - **주 목적**: 경로 탐색(예: 그래프 탐색, 미로 찾기).
            - **특징**:
                - "갈 수 있을 때까지 계속 간다" → 막히면 되돌아감.
                - 모든 경로를 다 탐색하는 것이 일반적.
                - **중간 가지치기(pruning)는 하지 않음.**
            - 예시:
                - 그래프의 연결 요소 찾기
                - 미로에서 출구가 있는지 확인
            
            ## ✅ 백트래킹 (Backtracking)
            
            - **정의**: DFS 탐색 과정에서 "해답이 될 수 없는 경우"를 빨리 포기하고(가지치기), 다른 경로를 탐색하는 방법.
            - **주 목적**: 모든 경우의 수 중 **조건을 만족하는 해**를 찾기 (최적화 or 제약 충족 문제).
            - **특징**:
                - DFS 기반으로 동작하지만, **불필요한 탐색을 줄이기 위해 가지치기**를 함.
                - "가능성이 있는 경로만 탐색".
                - 대표적으로 **순열, 조합, N-Queens, 부분집합 문제** 등에서 사용.
            - 예시:
                - N-Queens 문제 (퀸이 서로 공격하지 않는 위치에 놓기)
                - 부분집합 합 문제 (특정 합을 만족하는 조합 찾기)
            
            👉 한마디로 정리하면:
            
            - **DFS는 모든 경로를 끝까지 탐색하는 기본 방법**
            - **백트래킹은 DFS에 "가지치기"를 추가해서, 불필요한 경로는 탐색하지 않는 방법**