- 2차원 배열
    
    arr = [0,1,2,3],[4,5,6,7] → 2행 4열의 2차원 List(초기화)
    
    ⇒ arr[1][2] = 6
    
    입력 예시
    
    N과 2차원 배열이 주어짐
    
    ↓
    
    3                     N = int(input)                   ← N x N 의 2차원배열
    
    1 2 3               arr = [list(map(int, input().split())) for _ in range(N)]
    
    4 5 6              ( 배열의 내용물이 다 ‘0’처럼 같은 숫자로 채워진 3x4 배열이라면)
    
    7 8 9              arr = [[0] * 4 for _ in range(3)]
    
    얕은 배열X → 기본 2차원배열은 각 행을 가리키지만 복사된 2차원배열은 한 개의 행만 가리키기 때문에 만들면 안됨!
    
    배열 순회
    
    ```python
    # ex) n x m 배열의 모든 원소 조사
    
    for i in range(n):
    		for j in range(m):
    				f(array[i][j])    # 필요한 연산 수행
    ```
    
    열 우선 순회
    
    i 행의 좌표, j 열의 좌표
    
    ```python
    for j in range(m):
    		for i in range(n):
    				f(array[i][j])   # 필요한 연산 수행
    ```
    
    지그재그 순회
    
    i 행의 좌표, j 열의 좌표
    
    ```python
    for i in range(n):
    		for j in range(m):
    				f(array[i][j + (m-1-2*j) * (i%2)])   
    ```
    
    ※ x, y는 되도록 변수로 쓰지 않을 것~
    
- 델타:
    
    2차원 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
    
    인덱스(i, j)인 칸의 상하좌우 칸(ni, nj)
    
    ![image.png](attachment:e9817119-53f8-414d-86a8-2629753389b0:image.png)
    
    ```python
    di[] <- [0, 1, 0, -1]  # 방향별로 더할 값
    dj[] <- [1, 0, -1, 0] 
    
    for k : 0 -> 3    # 방향
    	ni <- i + di[k]
    	nj <- j + dj[k]
    ```
    
    ```python
    # 방법 1
    arr[0...N-1][0...N-1] # NxN 배열
    di[] <- [0, 1, 0, -1] 
    dj[] <- [1, 0, -1, 0]
    for i : 0 -> N-1:
    		for j : 0 -> N-1:
    				for d in range(4):
    						ni <- i + di[d]
    						nj <- j + dj[d]
    						if 0 <= ni < N and 0 <= nj < N   # 유효한 인덱스면
    								f(arr[ni][nj])
    		
    # 방법 2
    for i in range(N)
    		for j in range(M)
    				for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]:
    						ni, nj = i+di, j+dj
    				...
    ```
    
    델타 응용
    
    : 지도 문제에서 갈 수 있는 곳을 탐색하는 형태로 자주 출제됨
    
    ex) NxN 배열에서 각 원소를 중심으로, 상화좌우 K칸의 합계 중 최대값 (k=2)
    
    ![image.png](attachment:20178f03-141c-4acd-9a18-b9a95e8443b1:image.png)
    
    ```python
    max_v = 0
    for i in range(N):
        for j in range(N):
            s = arr[i][j]                                 # i, j를 중심으로
            for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]:    # 각 방향 선택
                for c in range(1, k+1):                   # 거리별
                    ni, nj = i+di*c, j+dj*c
                    if 0 <= ni < N and 0 <= nj < N:       # 경계를 벗어나는지 체크
                        s += arr[ni][nj]
            if max_v < s:
                max_v = s
    
    ```
    
    추가적으로,
    
    ![image.png](attachment:46a8f1c6-4f04-4d87-9b71-fac62ed97bc6:image.png)
    
    ![image.png](attachment:1f37c991-8da3-4a33-a18d-0fa850a70085:image.png)