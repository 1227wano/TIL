- 연산
    
    P. 37
    
    로봇이 상하좌우로 모두 이동할수있는 칸 문제
    
    ![image.png](attachment:13fe5054-820b-406f-a6c2-acea175b4aac:image.png)
    
    ```python
    for i in range(1, N-2)
    		for j in range(1, N-2)
    				cnt = 0 
    				for d in range(4)
    					ni = i + di
    					nj = j + dj
    				if 0 < ni < N and 0 < nj < N:
    						if text[ni][nj] == '0' or == '#'    # point 로봇이 원래 있던 자리도 생각하기!
    								cnt += 1
    				for d ---
    						if text[][] == '0'
    								break
    				else:                   # for-else문도 활용하기!
    						answer += 1
    ```
    
    문자열 뒤집기
    
    ```python
    s = 'Reverse'
    s = s[::-1]    # esreveR
    
    s = 'abcd'
    s = list(s)
    s.reverse()
    s = ''.join(s)
    ```
    
    문자열 비교
    
    - == 연산자와 is 연산자
        - ==는 값(value)이 같은지 비교
        - is는 객체의 정체성(identity), 즉 **같은 객체(메모리주소)**인지 비교
        - ==연산자는 내부적으로 특수 메서드 __eq__()를 호출
    
    ```python
    a = [1,2,3]
    b = [1,2,3]
    print(a == b)  # True (값이 같음)
    print(a is b)  # False (다른 객체임)
    ```
    
    C와 Java에서의 문자열 비교
    
    - C : strcmp() 함수를 사용
    - Java : ==연산자는 객체의 주소(참조)를 비교 (Python의 is)
               equals()메소드는 객체의 내용을 비교 (Python의 ==)
    
    사전 순서 비교
    
    - < 연산자를 사용해서 유니코드를 비교함
    - 대문자 → 소문자 순서라서 Zebra < apple = True 임
    
    문자열을 숫자로 변환
    
    ```python
    a = int(’123’)
    b = float(’3.14’)
    c = int(’A0’, 16)   # 문자열 ‘A0’를 16진법으로 해석해서 변환 → 160 이 됨
    ```
    
    숫자를 문자열로 변환
    
    a = str(123)
    
    b = str(3.14)
    

- 패턴매칭
    
    고지식한 패턴 검색(Brute Force)
     : 본문 문자열을 처음부터 끝까지 순회하면서 패턴 내의 문자들을 일일이 비교
    
    시간 복잡도는 O(MN)
    
    ```python
    def brute_force(p, t):  # p 찾을 패턴, t 본문 문자열, 패턴이 있으면 인덱스, 없으면 -1 리턴
        i = 0  # t의 인덱스
        j = 0  # p의 인덱스
        M = len(p)
        N = len(t)
        while j < M and i < N:
            if t[i] != p[j]:  # 다른 글자인 경우
                i = i - j
                j = -1
            i = i + 1
            j = j + 1
        if j == M:
            return i - M  # 검색 성공
        else:
            return -1  # 검색 실패
    ```
    
    KMP 알고리즘
    
    - 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
    - 시간 복잡도는 O(M+N)
    
    보이어 무어 알고리즘
    
    - 상용 소프트웨어에서 채택하고 있는 알고리즘
    - 실제 검색에서 매우 빠른 성능
    - 패턴 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우 이동거리는 패턴의 길이 만큼이 됩니다.
    - 존재하는 경우에는 일치한 부분을 고려해 점프함
    
    ![image.png](attachment:54e75263-48a0-40ee-a15a-e7e0da7fa335:image.png)
    

- 문자열 암호화
    - 시저 암호
    : 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 [평행이동] 시킴으로써 암호화
    - 단일 치환 암호화
    - 문자열 압축