알고리즘은 어떤 순서로 고민?

→ 완탐

→ 전체 경우를 모두 돌아보는 경우

→ 시간 복잡도 이슈

+ 가지치기(경우의 수를 줄여보자)

→ 규칙 찾기 (Greedy)

→ 그리디로 안되네?

→ 동적 계획법 (DP)

- 점화식

→  다른 알고리즘

- 반복과 재귀
    - 반복과 재귀는 유사
    - 반복은 수행하는 작업이 완료될 때까지 계속 반복
    - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
    - 재귀호출은 n중 반복문과 같은 효과
    
    Q. N을 입력 받아 N자릿수 조합 만들기
    
    → 만약 N = 9라면, 111111111 ~ 999999999 까지 출력 ⇒ N 중 반복문 X
    
    → 재귀 호출로 N중 for문 구현해야 함
    
    - 재귀 예시
    
    ```python
    def kfc(n):
    		if n == 4:   # 종료조건(기저조건 - base case) : 3
    				return
    		kfc(n + 1)
    		print(n)
    		
    kfc(0)
    ```
    

- 순열
    
    순열이라고..? 무례하긴 순애야
    
    : 서로 다른 N개 에서 R개를 중복 없이, 순서를 고려하여 나열하는 것
    
    중복 순열 (Permutation)
    
    : 서로 다른 N개 에서 R개를 중복을 허용하고, 순서를 고려하여 나열하는 것
    
    - 구현원리
        1. 재귀호출을 할때마다 이동경로를 흔적으로 남김 ( 헨젤과 그레텔의 빵가루처럼)
        2. 가장 마지막 레벨에 도착했을때 이동 경로를 출력
    
    ```python
    path = []               # 전역 리스트
    
    def kfc(x):
        if x == 2:          # 2개의 카드를 고를거니까 2
            print(path)
            return
    
        for i in range(3):  # 0,1,2를 고를거니까 선택지인 3
            path.append(i)  # 재귀호출을 하기전에 이동할 위치를 path리스트에 기록
            kfc(x + 1)
            path.pop()      # 기록 삭제
    
    kfc(0)
    ```
    
    (중복없는)순열 구현
    
    - 중복순열 코드 작성 → 중복 제거하는 코드를 추가하면 순열 코드가 됨
    - 중복 제거 원리 : 전역 리스트로 이미 선택한 숫자인지 구분 (used 배열)
    
    ```python
    path = []               # 전역 리스트
    used = [False] * 7      # 1 ~ 6 까지의 카드 숫자 사용여부
    
    def kfc(x):
        if x == 3:          # 2개의 카드를 고를거니까 2
            print(path)
            return
    
        for i in range(1, 7):  # 1 ~ 6 중 고를거니까
            # 중복제거
            if used[i]:     #
                continue
    
            used[i] = True
            path.append(i)  # 재귀호출을 하기 직전에 이동할 곳의 위치를 path 리스트에 기록
            kfc(x + 1)
    
            # 기록 삭제 과정
            path.pop()
            used[i] = False
    
    kfc(0)
    ```
    
- 완전탐색
    1. 주사위 눈의 합
    
    ```python
    path = []               # 전역 리스트
    cnt = 0
    
    def dice(x, sum):
        global cnt
        if sum > 10:        # 가지치기(누적합이 10넘어가면 더 탐색 필요없음)
            return
    
        if x == 3:          # 2개의 카드를 고를거니까 2
            cnt += 1
            return
    
        for i in range(1, 7):  # 1 ~ 6 중 고를거니까
            path.append(i)  # 재귀호출을 하기 직전에 이동할 곳의 위치를 path 리스트에 기록
            dice(x + 1, sum + i)
            path.pop()
    
    dice(x= 0, sum= 0)
    print(cnt)
    ```
    
- 정리
    
    완탐
    
    - 반복문이던 재귀호출이던 상관없음
    - 단순 반복문으로 구현되면 best
    - N 중 for 문 구조라면 재귀호출
    - 중복순열, 순열
        
        

password 녹화