0917 문제풀이 3

- 시간복잡도
    - 백트래킹
        - 재귀호출 기반으로 안되는 케이스를 제거
        - 교과서 적으로 최악 : 모든 경우 탐색 (N^N, N!, 2^N)
        - 어느정도 제거할 수 있을까? → 대략적으로 푼다
        
        ⇒ 보통 N이 크지 않다
        
    - union-find
        - 단순 union-find : O(N)
        - 경로 압축 : 조금 느린 O(1) == O(역아커만(N))
            - 매우 느리게 커지는 함수
        - rank + 경로 압축 : 거의 O(1)
    - prim ( 정점을 기준으로 BFS처럼 탐색 )
        - 힙에 간선 후보를 넣고 최소값을 뽑아간다
        - O(VlogV + ElogV)  → O(ElogV)
            - VlogV : 각 정점일 힙에 들어가야 한다
            - ElogV : 간선의 수 만큼 힙에 들어갈 수 있다
                - 우리가 배운 코드는 정점이 중복되게 삽입 : O(ElogE)
                    - decrease key 까지만 들어가 있다
                - 최적화 기법을 써야 함
            - ( 피보나치 힙을 쓰면 훨씬 빨라진다 )
    - kruskal ( 간선 전체를 보자 )
        - 간선들을 정렬 + 간선들을 선택 ( 사이클 검사하며 )
           O(ElogE)              E*O(1) - Union-Find
    - dijkstra ( 정점에서 누적거리가 짧은 노드만 선택 )
        - 간선들이 힙에 들어가는 시간
            E               O(logV)                      → O(ElogV)
    
- 1251 하나로
    - 노드 번호를 임의로 지정해야 함
    - 가중치 계산을 별도로 해야 함
    - 각 섬을 연결하는 간선들을 만들자
    - MST 구성
        - 밀집그래프라면 최악케이스가 없어서 prim이 훨씬 빠르지만 보통 잘 없다? → kruskal 로 풀기
    - 간선의 수 : 1000(섬의 수) * 999(섬 하나가 연결될 수 있는 다리) = 약 백만 개
    - 풀이
        1. 간선들 정보를 모두 저장
        2. 가중치 기준 오름차순 정렬
        3. 사이클 검사하면서, 앞에서부터 간선들을 선택  —> N-1개 선택(MST 구성)까지
        4. union-find → 경로 압축 버전
        5. 마지막 출력할 때 소수점 자르기 : 변수.0f
    
- 1249 보급로
    - 최단 거리~ 다익스트라~
    - 그래프 문제와의 차이점
        - 이동 가능한게 상하좌우 4개 방향
        - 최단 거리를 저장할 리스트를 2차원으로 구성해야 함 ( 초기값은 21억 일케 )
        [ 기존 ] 특정 노드까지 가는 최단 거리
        [ 문제 ] 특정 좌표까지 가는 최단 거리
    - 기존처럼 힙큐에 (누적거리(가중치), 노드번호) 가 아닌 (누적거리, y,x좌표) 를 취급
    - 풀이
        1. 시작점(0,0)을 기준으로 델타로 이동 범위 확인
        2. 누적거리 계산 = 현재까지의 거리 + 다음 거리
    
- 4012 요리사
    
    
- 4008
    - 백트래킹
    - 먼저 취급할 연산자 체크
    - 누적값 : 몇개의 숫자를 고려했는지, 계산된 결과, 남은 연산자 수
    - 가지의 수 : 최대 4개( 연산자가 없으면 못쓴다 )
    
- 정리
    - 웹, AI 과정으로 나아가며, 알고리즘 1일 1문제? 추가 학습 하기? 개인의 속도대로
    - 생성형 AI한테 코테 자주 출제되는 유형 기업별로 추천받기?
    -