- Queue
: 선입선출(FIFO)인 자료구조
    
    큐는 머리(Front)와 꼬리(Rear)로 나뉨
    
    머리 : 저장된 원소 중 첫번째 원소 또는 삭제된 위치 / 꼬리 : 마지막 원소
    
    기본연산 : 
    
    enqueue(item) : 삽입
    
    dequeue() : 삭제
    
    create_queue() : 빈 큐를 생성하는 연산
    
    is_empty() : 큐가 빈 건지 확인
    
    is_full() : 큐가 포화상태인지
    
    qpeek() : 큐의 앞쪽에서 원소를 삭제없이 반환하는 연산
    
    연산과정 : 
    
    1. create_queue() : 공백 큐 생성
    2. enqueue(A) : 원소 A 삽입  → front = rear = A
    3. enqueue(B) : 원소 B 삽입   → front = A / rear = B
    4. dequeue() : 원소 반환 / 삭제  → front = rear = B
    5. enqueue(C) : 원소 C 삽입  → front = B / rear = C
    6. dequeue() : 원소 반환 / 삭제  → front = rear = B
    7. dequeue() : 원소 반환 / 삭제 → empty
    
- 선형 큐
: 데이터를 일렬로 저장하며, 앞에서 꺼내고 뒤에 넣는 기본 큐 구조7
    
    구현
    
    - 배열이나 연결형 리스트로 구현 ( 큐의 크기 = 배열의 크기 )
    - front : 가장 최근에 삭제된 원소의 인덱스
    - rear : 마지막으로 저장된 원소의 인덱스
    
    상태표현
    
    - 초기 상태 : front = rear = -1
    - 공백 상태 : front == rear
    - 포화 상태 : rear == n-1 ( n : 배열의 크기, n-1 : 배열의 마지막 인덱스 )
    
    구현 코드
    
    ```python
    # 큐 생성 create_queue() 
    q = [0] * n
    front = -1
    rear = -1
    # 삽입 enqueue(item)
    enqueue(item):
    		global rear
    		if is_full() : print('큐 포화')
    		else : 
    				rear <- rear + 1
    				q[rear] <- item
    # 삭제
    dequeue()
    		if(is_empty()) then queue_empty():
    		else
    				front <- front + 1:
    				return Q[front]
    # 상태 검사
    is_empty() :
    		return front == rear
    is_full()
    		return rear == lem(q)-1
    # 검색
    def qpeek() :
    		if is_empty() : print('Queue_Empty')
    		else : return q[front+1]
    ```
    
- 원형 큐
    
    선형 큐로 삽입삭제를 계속할 경우, front는 가장 먼저 나갈수있는 ‘인덱스’이기 때문에,
    
    배열의 앞 부분에 활용할 수 있는 공간이 있음에도 rear = n-1 인 포화상태로 인식하여 더이상 삽입을 수행하지 않게 됨
    
    해결방법
    
    1. 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동 (많은 시간이 소요되어 큐의 효율성 급락)
    2. 1차원 배열 사용 : 논리적으로는, 배열의 처음과 끝이 연결되어 원형 상태를 이룬다고 가정
    ⇒ 원형 큐
    
    원형 큐의 구조
    
    - 초기 공백 상태
        - front = rear = 0
    - 인덱스의 순환
        - front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킴
        - 그 다음엔 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동
        - 이를 위해 나머지 연산자 mod 를 사용
    - front 변수
        - 공백 상태와 포화 상태를 구분하기 쉽게 front가 있는 자리는 사용하지 않고 빈자리로
    
    연산 과정
    
    : rear가 마지막 인덱스가 된 후, 새롭게 삽입될 때 배열 첫 인덱스에 삽입하고 rear 가 된다
    
    ```python
    # 큐 생성
    cq = [0] * n
    front = rear = 0
    # 삽입
    def enqueue(item) :
    		global rear
    		if is_full() :
    				print('queue_full')
    		else :
    				rear = (rear + 1) % len(cq)
    				cq[rear] = item
    # 삭제
    def dequeue()
    		global front
    		if is_empty() :
    				print('queue_empty')
    		else : 
    				front = (front + 1) % len(cq)
    				return cq[front]
    # 상태 검사
    def is_empty() :
    		return front == rear
    def is_full() : 
    		return (rear+1) % len(cq) == front
    ```
    
- 연결 큐 ( Linked (list) Queue )
    
    deque(덱)
    
    : 컨테이너 자료형 중 하나로, 양쪽 끝으로 빠르게 추가와 삭제를 할수있는 리스트류 컨테이너
    
    → 연결 리스트를 직접 만들지 않아도 됨
    
    deque의 연산
    
    - append(x) : 오른쪽에 x 추가
    - popleft() : 왼쪽에서 요소를 제거하고 반환, 요소가 없으면 IndexError
    
    ```python
    from collections import deque
    
    q = deque()
    q.append(1)  # enqueue()
    t = q.popleft() # dequeue()
    ```
    
- 우선순위
: 우선순위를 가진 항목들을 저장하는 큐
    
    LIFO, FIFO 가 아닌 우선순위가 높은 순서대로 먼저 나감
    
    적용 분야로 시뮬레이션시스템, 네트워크트래픽제어, 운영체제의 테스크스케줄링 등
    
    - 배열을 이용하여 자료 저장
    - 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입
    - 가장 앞에 최고 우선순위의 원소가 위치
    - 배열을 사용하므로, 삽입/삭제 연산이 일어날때 원소의 재배치 문제
    - 소요되는 시간 / 메모리 낭비 심함 문제
    
    버퍼
    : 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 보관하는 메모리 영역
    
    일반적으로 입출력 및 네트워크와 관련된 기능에서 이용됨
    
    순서대로 입출력/전달 되어야하므로 FIFO 방식
    
    예시 :
    
    ![image.png](attachment:07280658-ddb7-4f83-b8f8-53e60793f74f:image.png)
    
    ![image.png](attachment:eb7ef535-24c5-4ccb-a192-6ddac19d3d3d:image.png)