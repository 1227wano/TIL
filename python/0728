- **0728**
- Data Structure (데이터 구조 = 자료 구조)
  : str, list, dict 등
    
  메서드
   각 데이터 구조의 메서드를 호출하여 다양한 기능 활용하기
    ex) list의 append()
    = 객체에 속한 함수
    
  메서드는 어딘가(클래스)에 속해 있는 함수, 각 데이터 타입 별로 다양한 기능을 가진 메서드 존재
    문법 : 
    데이터타입객체.메서드() → ‘hello’.capitalize()
    
- 시퀀스 데이터 구조
  문자열 
   : (is ~ 말고는) 문자열 조작 메서드 ⇒ 문자열은 조작 불가니, 새로운 문자열을 반환하는 것임
    
    1. find(x) : x의 첫 번째 위치 반환, 없으면 -1 반환
    2. index(x) : x의 첫 번째 위치 반환, 없으면 에러 발생
    3. isupper() : 문자열 내의 모든 문자가 대문자인지 확인
    4. islower() : 문자열 내의 모든 문자가 소문자인지 확인
    5. isalpha() : 문자열 내의 모든 문자가 알파벳인지 확인
    6. replace(old, new[,count])
        : (count 는 선택인자여서 바꿀 개수를 뜻) 바꿀 대상 글자를 모두 새로운 글자로 바꿔서 변환
    7. strip([chars]) : 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
    8. split(sep=None, maxsplit=-1)
        : sep를 구분자 문자열로 사용하여, 문자열에 있는 단어들의 리스트를 반환
    9. ‘separator’.join(iterable)
        : iterable(반복가능한 객체)의 문자열을 ‘separator’로 연결한 문자열을 반환
    10. title() : 문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자, 나머지는 소문자로
    11. upper() : 모두 대문자로
    12. lower() : 모두 소문자
    13. swapcase() : 대 ↔ 소문자를 서로 변경
    
  리스트 값 추가 및 삭제 메서드 → 원본에 조작이 가해짐 ⇒ 반환값이 없음
    
    1. append(x) : 리스트 마지막 항목에 x를 추가
    2. extend(iterable) : iterable의 모든 항목들을 리스트 끝에 추가 (+=와 같음)
    3. insert(i, x) : 리스트 인덱스 i에 항목 x를 삽입
    4. remove(x) : 첫 번째 x를 제거, 항목이 존재하지 않으면 ValueError
    5. pop() : 리스트 가장 마지막 항목을 반환 후 제거
    6. pop(i) : 리스트의 인덱스 i에 있는 항목을 반환 후 제거
    7. clear() :  리스트의 모든 항목 삭제
    
  리스트 탐색 및 정렬 메서드
    
    1. index(x) : 리스트에서 첫 번째로 일치하는 항목 x 의 인덱스 반환
    2. count(x) : 리스트에서 항목 x의 개수를 반환
    3. reverse() : 리스트의 순서를 역순으로 변경(정렬X)
    4. sort() : 리스트를 오름차순으로 정렬 (매개변수 이용가능 : reverse=True 등) 
    
- 복사
  객체와 참조
  가변(Mutable) / 불변(Immutable) 객체의 개념 
    : 생성 후 내용을 변경할 수 있는(list, dict, set) / 없는(int, float, str, tuple) 객체
    
  변수 할당의 의미
    - 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정
    - 변수는 객체의 메모리 주소를 가리키는 Label 역할을 함
    - =연산자를 사용하여 변수에 값을 할당, 
    할당 시 새로운 객체가 생성되거나 기존 객체에 대한 참조가 생성됨
    
  가변 / 불변 메모리 관리 방식의 이유
   - 성능 최적화
     - 불변 객체 : 변경이 불가하므로, 여러 변수가 동일한 객체를 안전하게 공유 가능
     - 가변 객체 : 내용 수정이 빈번할 때, 새로운 객체를 생성하는 대신 기존 객체를 직접 수정 가능
       이로 인해 객체 생성 및 삭제에 드는 비용을 절감하여 성능을 향상
    
  얕은 복사 (Shallow Copy)
    1. 리스트 슬라이싱 
    2. copy() 메서드 
    3. list()  함수 
  얕은 복사의 한계 : 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우
        
  깊은 복사 
   : 객채의 모든 수준의 요소를 새로운 메모리에 복사하는 방법
    중첩된 객체까지 모두 새로운 객체로 생성됨
    
    copy 모듈에서 제공하는 deepcopy() 함수를 사용
    
- 참고
  - List Comprehension !
    간결하고 효율적인 리스트 생성 방법 ⇒ “Pythonic”한 코드
        
  - 리스트 생성 시
    문법 : 새로운 리스트 생성구문없이, []에 for문 첫 문장을 넣고, 맨 앞에 넣을 식을 작성
        
    ex)
    # 사용 전
    numbers = [1, 2, 3, 4, 5]
    squared_numbers = []
    for num in numbers:
        squared_numbers.append(num**2)
    
    # 사용 후
    numbers = [1, 2, 3, 4, 5]
    squared_numbers = [num**2 for num in numbers]
    
    print(squared_numbers) # [1, 4, 9, 16, 25]
        
  - 2차원 배열 생성 시 (인접행렬 생성)
    
    ex)
    data1 = [[0 for _ in range(5)] for _ in range(5)]
    # 또는 
    data2 = [[0] * 5 for _ in range(5)]
        
    ! 컴프리헨션을 남용하지 말 것 → 코드 이해 어려워짐 !
    ”Simple is better than complex” “Keep it simple, stupid”
        
    <성능 비교>
    
    1. list comprehension
        - 가장 'Pythonic'하고 대부분의 경우 우수한 성능을 보임
    2. map
        - 특정 상황(int, str 등 내장 함수와 함께 사용할 때)에서 가장 빠름
        - 사용자가 직접 만든 함수나 lambda와 함께 사용될 때는 list comprehension과 성능이 비슷하거나 약간 느릴 수 있음
    3. for loop
        - 일반적으로 가장 느리다고 알려져 있지만,
            python 버전이 올라가면서 다른 방식과 비슷하거나 때로는 더 나은 결과를 보이기도 함
        - 하지만, 여러 줄에 걸친 복잡한 조건문이나 예외 처리 등이 필요할 때는 유일한 선택지이며, 그 자체로 매우 유용함
    
    결론
    - 성능 차이는 대부분의 경우 마이크로초 단위로 미미하므로, 
        코드의 가독성과 유지보수성을 최우선으로 고려하여 상황에 맞는 가장 명확한 방법을 선택하는 것을 권장
        
  - 메서드 체이닝
    : 여러 메서드를 연속해서 호출하는 방식
        
   주의 사항
    : 모든 메서드가 체이닝을 지원하는건 X
    : None을 반환하는 메서드는 메서드 체이닝이 불가능 ( append(), sort() 등)
    :  메서드 체이닝을 사용할때는 각 메서드의 반환 값을 잘 이해하고 있어야함
        
    
   - 문자 유형 판별 메서드
    isdecimal() : 문자열이 모두 숫자 문자(0-9)로만 이루어져 있어야 True
    isdigit() :  위와 비슷하지만, 유니코드 숫자도 인식
    isnumeric() : 위와 비슷하지만, 몇가지 추가적인 유니코드 문자들도 인식(분수, 루트 등)