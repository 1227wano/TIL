- **0723**
- 함수 
: 특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
    ex) 
    def get_sum(num1, num2) :
    return num1 + num2
    
  함수 호출
    ex) 
    num1 = 5 num=3
    sum_result = get_sum(num1, num2)
    
  함수 구조
    현업에서는 Docstring (설명서) 도 작성하여 함수를 설명
    
  function body
    : 함수 선언 이후 들여쓰기되는 내용
    
  함수 정의
    - def(define) 키워드로 시작하여, 함수 이름 작성
    - 괄호 안에 매개변수(parameter)를 정의할 수 있으며, 함수에 전달되는 값을 작성
    
  함수 body
    - : 다음에 들여쓰기 된 코드 블록
    - 함수가 실행될 때 수행되는 코드 정의
    
  Docstring
    : 함수 body 앞에 선택적으로 작성 가능한 함수 설명서
    
  함수 반환값
    - 필요한 경우 결과 반환 가능 → return 키워드 이후에 반환값 명시
    - return 문은 함수의 실행을 종료하고, 결과를 호출 부분으로 반환
    - 함수 내에 return 문이 없다면 None 이 반환됨
    
  함수 호출
    - 사용을 위해선 호출 필요
    - 이름과 소괄호를 활용해 호출
    - 필요한 경우 인자(argument)를 전달해야함
    - 호출 부분에서 전달된 인자는 함수 정의시 작성한 매개변수에 대입됨
    
  print()
    - print() 함수는 화면에 값을 출력하기만 할 뿐, 반환값이 없음
    - 파이썬에선 반환값이 없으면 None이 반환되니까
    
    ex)
    return_value = print(1)
    print(return_value)
    
    print() 는 화면에 인자를 출력할 뿐 반환값은 없기 때문에 return_value에 담아도 1이 아닌 None이 전달되어, 
    이 함수를 출력해도 1이 아닌 None이 출력됨
    
  매개변수와 인자
   매개변수 
    : 함수를 정의할 때 함수가 받을 값을 나타내는 변수
    
   인자
    : 함수를 호출할 때 실제로 전달되는 값
    
   다양한 인자 종류
    - 위치 인자(Positional Arguments)
        - 함수 호출 시 인자의 위치에 따라 전달되는 인자
        - 위치 인자는 함수 호출 시 반드시 값을 전달 해야함
        - 매개변수의 개수만큼 인자도 입력해야함
    - 기본 인자 값(Default Argument Values)
        - 함수 정의에서 매개변수에 기본 값을 할당하는 것
        - 함수 호출 시 인자를 전달하지 않으면 기본값이 매개변수에 할당됨
    - 키워드 인자(Keyword Argument)
        - 함수 호출 시 인자의 이름과 함께 값을 전달하는 인자
        - 인자의 순서 상관없이 일치시키지 않고 인자의 이름을 명시하여 특정 매개변수에 값을 할당 가능
        - 단 호출 시, 키워드 인자는 위치 인자 뒤에 위치해야함
    - 임의의 인자 목록(Arbitrary Argument Lists)
        - 정해지지 않은 개수의 인자를 처리하는 인자
        - 함수 정의시 매개변수 앞에 * 를 붙임
        - 여러 개의 인자를 tuple 로 처리
    - 임의의 키워드 목록(Arbitrary Keyword Argument Lists)
        - 함수 정의시 매개변수 앞에 ** 를 붙임
        - 여러 개의 인자를 dictionary 로 처리
    
  함수 인자 권장 작성 순서
    - 위치 → 기본  →  가변 → 가변 키워드
    - 호출 시 인자를 전달하는 과정에서 혼란을 줄이도록
    - 단, 절대적인 규칙은 아님
    
- 재귀(Recursion) 함수
  : 함수 내부에서 자신을 호출하는 함수
    
    예시
    
  팩토리얼 (이런거→ n!)
    factorial 함수는 자신을 재귀적으로 호출, n의 팩토리얼을 계산
    n이 0이 될때까지 반복되니, 종료 조건을 설정하여 재귀 호출이 멈추도록!
    ⇒ 재귀 호출의 결과를 이용하여 문제를 작은 단위의 문제로 분할하고 그 결과들을 조합하여 최종 결과를 도출
    
  특징
    - 특정 알고리즘 식을 표현할때 변수의 사용이 줄어들며 코드의 가독성이 높아짐
    - 1개 이상의 base case(종료되는 상황)가 존재하고 수렴하도록 작성
    - if 문 등 return 값에도 재귀함수 호출 가능! 
    ex) *return* (number % 10) + sum_of_digits(number // 10)
    
  주의
    - 종료 조건을 명확히 할 것
    - 반복되는 호출이 종료 조건을 향하도록 할 것
    
  사용하는 이유
    - 복잡한 문제를 간결하고 자연스럽게 표현
    - 상황에 따라 반복문보다 알고리즘 코드가 더 간결하고 명확해질수있음
    - 수학적 정의가 재귀적으로 표현된다면, 직접적인 구현 가능
    
- 내장 함수(Built-in function)
  print(), len() 같은 기본적으로 파이썬이 제공하는 함수(import)없이 사용 가능
    
  sorted() : 정렬 내장함수
   기본 문법 → sorted(정렬할 자료, key=정렬기준함수) 
    ex) sorted(numbers, reverse=True) → 역순 정렬
    ex) sorted_students = sorted(students, key=lambda student_data: student_data[0])
   → lambda를 쓰면 따로 정렬기준함수 만들어서 호출하는 과정이 생략됨
    
- Scope
    함수는 코드 내부에 local scope 를 생성하며, 그 외의 공간인 global scope 로 구분

  이름 검색 규칙(Name Resolution)
    - 파이썬에서 사용되는 이름(식별자)들은 특정한 이름공간(namespace)에 저장돼있음
    - 아래와 같은 순서로 이름을 찾아 나가며 LEGB Rule 이라고 부름
    
  global 키워드
    : 변수의 스코프를 전역 범위로 지정 (global 키워드 다음에 변수 선언)
    일반적으로 함수 내에서 전역 변수를 수정하려는 경우에 사용
    
  주의
    - global 키워드 선언 전에 참조 불가
    - 매개변수에는 사용 불가
    
  - 함수 규칙
   이름 스타일 가이드
    - 스네이크케이스, 동사로 시작하여 동작 설명
    - 약어 사용 지양
    - get / set 자주 사용, T/ F 를 반환한다면 is 나 has 추천
    - 플젝 전체에서 일관성을 지키는 것이 가독성에 도움
    
  단일 책임 원칙
    : 모든 객체는 하나의 명확한 목적과 책임 만을 가져야 함
    
- Packing & UnPacking
    
  패킹
   : 여러 개의 값을 하나의 튜플로 묶는 파이썬의 기본 동작.
    한 변수에 ,로 구분된 값을 넣으면 자동으로 튜플로 처리
    
  * / ** 를 활용한 패킹
    남는 키워드 인자들을 튜플 / 딕셔너리로 묶기
    이러면 print()로 한번에 여러 개 출력 가능
    
  언패킹
   : 튜플이나 리스트 등의 객체의 요소들을 개별 변수에 할당
    시퀀스 언패킹 또는 다중 할당 이라고 부름
    
    * / ** 를 할용하여 존재하는 튜플이나 딕셔너리를 변수의 각 값에 할당
    
- 함수와 반환
    
    함수는 언제나 단 하나의 값(객체)만 반환
    여러 값을 반환하는 경우에도 하나의 튜플로 패킹하여 반환
    반환된 튜플은 각 변수에 언패킹하여 사용 가능
    
- 람다 표현식
  : 익명(or 1회용) 함수를 만드는데 사용
   한 줄로 간단한 함수 정의
    
    def 가 아닌 lambda 키워드로 작성
    
    ex)
    # 변경 전
    def addition(x, y):
        return x + y
    
    # 변경 후
    lambda x, y: x + y
    