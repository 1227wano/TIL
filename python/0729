- 비시퀀스 데이터 구조
    
    딕셔너리
    : Key와 Value을 짝지어 저장하는 자료구조
    
    내부적으로 해시테이블을 사용하여 키-값 쌍을 관리
    
    - 메서드
        
        get(k)
        
         : 키 연결된 값을 반환하거나 키가 없으면 None 혹은 기본 값을 반환
        
         : get 메서드를 안써도 값을 받을수있지만, 기본값은 없고 에러가 발생함 ← 상황에 맞게 선택!
        
        get(k, v)
        
        keys()
        
         : 딕셔너리 키를 모은 객체를 반환
        
         : dict_keys([’name’, ‘age’]) - 실시간으로 동기화되는 확인창(View)
        
        values()
        
         : 딕셔너리 값들을 모은 객체를 반환
        
        items()
        
        : tuple의 형태로 Key와 Value가 튀어나옴
        
        pop(k)
        
        : [반환 + 제거] 키를 제거하고 연결됐던 값을 반환(없으면 에러나 defalut 반환)
        
        pop(k, v)
        
        clear()
        
        : 딕셔너리의 모든 키/값 쌍을 제거
        
        setdefault(k)
        
        : 키와 연결된 값을 반환
        키가 없다면 default와 연결한 키를 딕셔너리에 추가하고 defalut를 반환
        
        → 일단 get처럼 해당 키로 찾고, 없다면 해당 키와 defalut값을 한 쌍으로 딕셔너리에 추가함
        
        setdefault(k, v)
        
        update([other])
        
        : other가 제공하는 키/값 쌍으로 딕셔너리를 갱신하고 기존 키는 덮어씀
        
        : 딕셔너리 뿐만아니라, 키워드인자의 기본값 쌍도 적용가능
        
    
    세트
    : 고유한 항목들(중복없음)의 정렬되지 않은 컬렉션
    
    내부적으로 해시 테이블을 사용하여 데이터를 저장합니다.
    
    이로 인해 항목의 고유성을 보장하고, 항목의 추가, 삭제, 존재여부확인(in연산)이 데이터의크기에 관계없이 매우 빠릅니다.
    
    또한, 합집합, 교집합, 차집합 등 수학적인 집합 연산을 간편하게 수행할 수 있는 것이 가장 큰 특징입니다.
    
    → 가끔 리스트를 중복제거하고자 set로 변화하지만, set는 순서가 보장되지않으니 주의
    
    - 메서드
        
        add(x)
        
        : 세트에 x를 추가
        
        update(iterable)
        
        : 세트에 다른 iterable 요소를 추가
        
        clear()
        
        : 세트의 모든 항목 제거
        
        remove(x)
        
        : 세트에서 항목 x를 제거, 항목 x가 없을 경우 KeyError
        (’10’이라는 항목이 없으면 KeyError : 10 라고 뜸)
        
        pop()
        
        : 세트에서 임의의 요소를 제거하고 반환
        
        discard(x)
        
        : 세트 s에서 항목 x를 제거. remove와 달리 에러 없음
        
    - 집합 메서드
        
- 참고
    
    해시 테이블
    
    : Key와 Value를 짝지어 저장하는 자료구조
    
    1. 키를 해시 함수를 통해 해시 값으로 변환
    2. 변환된 해시 값을 인덱스로 삼아 데이터를 저장하거나 찾음
    3. 이로 인해, 검색 삽입 삭제를 매우 빠르게 수행
    
    해시 
    : 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것
    
    생성된 해시값은 해당 데이터를 식별하는 지문 역할을 함
    
    파이썬에서는 이 해시 값을 이용해 해시 테이블에 데이터를 저장
    
    이 변환을 수행하는 것이 해시 함수
    
    해시 함수
    
    : 임의 길이 데이터를 입력받아 고정길이(정수)로 변환해주는 함수. 이 정수가 바로 해시 값
    
    주로 해시 테이블을 구현할 때 매우 빠른 검색 및 데이터 저장 위치 결정을 위해 사용
    
    ‘해시 알고리즘’이라고도.
    
    set의 요소 & dict의 키와 해시 테이블 관계
    
    - set
        
        각 요소를 해시 함수로 변환해 나온 해시 값에 맞춰 테이블 내부 버킷에 위치시킴
        
        따라서 순서라기보단 버킷위치(인덱스)가 요소의 위치를 결정
        
        따라서 set는 순서를 보장하지 않음
        
    - dict
        
        키 → 해시 함수 → 해시 값 → 해시 테이블에 저장
        
        단, set와 달리 삽입 순서는 유지한다는 것이 언어 사양에 따라 보장됨
        
        즉, 키를 추가한 순서대로 반복문 순회할 때 나옴
        
        사용자에게 보여지는 키 순서는 삽입 순서가 유지되도록 설계된 것
        
    
    해시 난수화와 난수 시드
    
    : 파이썬 프로세스가 새로 시작될때마다 해시를 계산할 때 사용하는 난수 시드가 달라짐
    
    이로 인해 동일한 데이터라도, 매번 해시 값이 달라져 결과적으로 버킷 배치가 달라짐
    
    hashable
    
    hash() 함수에 넣어 해시 값을 구할 수 있는 객체를 의미
    
    대부분의 불변 타입은 해시 가능
    
    가변형 객체(list, dict, set)는 기본적으로 해시 불가능
    
    불변성 간의 관계
    
    해시 테이블(set, dict의 key)에는 hashable(해시가 가능한 객체)만 저장가능
    
    불변 객체는 생성 후 값 변경이 불가능하므로, 항상 같은 해시 값을 유지
    
    → 해시 테이블이 안정적으로 동작
    
    다만, “hash 가능하다 ≠ 불변이다” 가 절대적이지는 않지만, 일반적으로 내장 자료형 기준에서는 불변이어야 해시 가능
    
    hashable 객체가 필요한 이유
    
    1. 해시 테이블 기반 자료 구조 사용
        set의 요소, dict의 키
        중복 방지 & 빠른 검색, 조회
    2. 불변성을 통한 일관된 해시 값
        한 번 해시 값이 정해지면 바뀌지 않아야 해서 테이블 무결성이 유지
    3. 안정성과 예측 가능성 유지
        동일한 데이터는 항상 동일한 해시 값을 반환 → 로직을 단순화
    
    - 파이썬 문법 규격
        
        BNF : 프로그래밍 언어와 문법을 표현하기 위한 표기법 
        
        EBNF : BNF 를 확장한 표기법. 메타 기호를 추가하여 더 간결하고 표현력이 강해진 형태
        
        [] 는 선택적 요소. {} 는 0번 이상 반복, () 는 그룹화