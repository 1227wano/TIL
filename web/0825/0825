- Web
    - web site : HTML, CSS 등의 웹기술을 이용하여 만들어진 web page 가 모인 것
    - HTML : HyperText(웹페이지를 다른 페이지로 연결하는 링크) Markup Language(태그 등을 이용하여 문서나 데이터의 구조를 명시하는 언어
    - CSS : Cascading Style Sheet, 웹페이지의 디자인
- HTML
    
    HTML Attributes (CSS에서 스타일 적용할때도)
    - 하나 이상의 속성들이 있는 경우 속성 사이에 공백으로 구분
    ex) <p class=”ssapy”>이게 속성임</p>
    
    HTML Text Structure
    : 텍스트 구조와 의미를 제공하는 것 (<h1>는 텍스트 크기가 아니라 최상위 제목이라는 의미 부여임)
    
    <p> : 텍스트 문단을 만듦
    
    <a> : 하이퍼링크 태그
    
    <oi>, <ul>,<li> : 리스트 태크
    
    <em>, <strong> : Emphasis(특별 강조구문 이태릭체) & Importance(강조)
    
- CSS
    
    스타일은 인라인 > 내부 > 외부 순으로 우선 적용됨
    
    → 가독성, 유지보수성 적으로 인라인 잘 안씀
    
    ![image.png](attachment:db57efb4-6f3f-4384-bfc5-1a163551fb92:image.png)
    
    선택자
    
    - 기본 선택자
        - 전체 선택자 : *
        - 요소(tag) 선택자 : 지정한 태그 전체 선택
        - 클래스 선택자 : ( .클래스명 ) 식으로 선택
        - id 선택자 : ( #아이디 ) 로 선택, 하나만 존재
        - 속성 선택자 : []내부에 적은 속성값을 가진 모든 요소 선
    - 결합자
        - 자손 결합자 : (” “ (space) )
        ex) .green li → green 클래스 내의 모든 li 선택
        - 자식 결합자 (”>”)
        ex) ul > li → <ul> 안의 모든 <li> 선택
    
    값의 단위
    
    - 절대 단위 : px. pt, cm 등 다른 요소의 영향 받지 않음
    - 상대 단위 : %, em, rem, vw, vh 등 다른 요소의 크기에 따라 상대적으로 결정
        - rem : Root em ← em의 단점을 극복, 부모가 아닌 최상위 요소인 html을 기준으로 결정됨
            - 일광성 및 예측 가능성
            - 유지보수 용이성
            - 접근성 향상
    
    ![image.png](attachment:7f76808b-24bc-40ff-95d4-d5650069e76d:image.png)
    
    명시도가 높은 순으로 스타일이 적용됨
    
    1. !important 
     : 다른 우선순위 규칙보다 우선하여 적용하는 키워드
    → cascade의 구조를 무시하고 강제로 스타일을 적용하는 방식이므로 권장하지 않음
    2. Inline스타일 
    3. 선택자 ( id > class > attr ) 
    4. 소스코드선언 순서
    
    상속
    
    ![image.png](attachment:203b85ce-b9ae-4396-8a6a-344e55d24d6d:image.png)
    
    CSS Box Model
    
    ![image.png](attachment:f57c6854-c8fd-4847-854a-20620abc40bb:image.png)
    
    ![image.png](attachment:870fec65-f91a-42b8-9a59-3b47237bf0a5:image.png)
    
    ![image.png](attachment:00313d5c-0e2b-40ef-b6da-b29f3d7f408d:image.png)
    

- AI
    
    코딩 어시스턴트의 이해
    
    생성형 AI 작동 원리
    
    - 확률에 따라 단어(토큰)를 하나씩 선택하며 답변 생성
    - 생성형 AI는 이미지와 같이 값을 인식하므로 사칙연산을 할 수 없다
    - Chat GPT 는 토큰을 하나씩 선택하며 답변을 생성하는 GPT에 여러 도구(사칙 연산, 웹 검색, 코드 실행)를 연결한 챗봇 서비스
    
    AI 코딩 어시스턴트의 발전
    
    - GPT의 발전 + 여러 도구 (파일 작성 및 수정, 브라우저 조작)
        
        → 보조(Assistant)에서 대리인(Agent)으로 
        
    
    ![image.png](attachment:83dbdafb-6a46-47ab-b13f-663c40ce6c60:image.png)
    
    AI 시대, 코딩의 진화
    
    - AI 이전 시대
        - 개발자가 직접 코드 작성
        - 에러 발생시 공식문서, Stack Overflow 참고
    - 초기 AI 코딩 어시스턴트 (ChatGPT, Claude, Gemini CLI)
        - GPT도움 받으며 개발자가 직접 코딩
        - 에러 발생시 GPT의 답변 참고해 직접 해결
    - 최근 AI 코딩 어시스턴트 (Cursor AI, VS Code Copilot, Gemini CLI)
        - 대부분의 코드를 AI가 작성
        - 개발자는 AI에게 작업을 지시 (임무 지시) → AI 코드 작성 (임무 수행) → 개발자의 검수
    
    ⇒ 점점 더 많은 영역이 자동화
    
    AI 코딩 어시 활용 개발 생산성 향상
    
    - 고객
        - 빠른 MVP 개발
        - 고객과의 원활한 의사소통
        - 빠른 의사 결정
    - 동료 개발자
        - 개발자-기획자-디자이너 간 원활한 소통과 협업
        - 리스크 조기 발견
    - 시장
        - 빠르게 변하는 기술 환경에서 민첩하게 대응 가능
        - 제품 - 시장 적합성 확보 가능성 높아짐
    
    ![image.png](attachment:24f107b6-ef16-4b82-ad18-32da4c49ae35:image.png)
    
    Gemini CLI 기초 사용법
    
    tools 활용하기
    
    ![image.png](attachment:36529d84-7962-40c6-8205-5b0fd291c8c5:image.png)
    
    코드 작성 프로세스
    
    ![image.png](attachment:0e646fa3-1dda-41e2-ad50-1941f2802d0c:image.png)
    
    ![image.png](attachment:a95aee0c-4fec-4801-9426-2f70793b8174:image.png)
    
    → 좀더 효율적인 방법으로 AI에게 일을 시킬수있도록!
    
    Git 반영
    
    1. 깃헙 개인 레포 생성
    2. “git주소 레포지토리를 클론 받아줘”
    3. 만든 모든 파일을 만든 레포 폴더로 옮기기
    move 파일명 폴더주소
    4. 레포를 init으로 커밋후 push
    
    기타 Gemini CLI 단축키
    
    - /compress : 대화 요약
    - /chat save + <태그>: 태그라는 이름의 대화를 저장(checkpoint 생성)
    - /chat list : 대화 목록 조회
    - /chat resume + <태그> : 저장한 대화 불러와 이어서 대화가능
    - /chat delete + <태그> : 저장한 대화 삭제
    -