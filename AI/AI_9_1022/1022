# RAG 시스템과 RAG 에이전트(Agent)를 구축

RAG(Retrieval-Augmented Generation)의 기본 개념을 익히고, LangChain 라이브러리를 사용해 간단한 RAG 시스템과 RAG 에이전트(Agent)를 구축하기

[4_1_RAG.ipynb](attachment:24420a0f-1b18-45f2-b679-013ecb910d62:4_1_RAG.ipynb)

### 1. 환경 설정 및 API 키 로드 (1~7번 셀)

노트북 실행에 필요한 기본 환경을 설정하고, Upstage API 키를 로드하며, 관련 라이브러리를 설치합니다.

- **셀 1 (Markdown):**
    - `# 환경 설정`
    - '환경 설정' 섹션의 시작을 알리는 제목입니다.
- **셀 2 (Code):**
    - Google Colab 환경에서 사용자의 Google Drive를 `/content/drive` 경로에 연결(마운트)합니다.
    - 작업을 위한 기본 경로(`base_path`)를 설정하고, 해당 경로에 디렉터리가 없으면 `mkdir` 명령어로 생성합니다.
- **셀 3 (Code):**
    - `!echo` 셸 명령어를 사용하여 `base_path`에 `.env` 파일을 생성합니다.
    - 이 파일 안에 `UPSTAGE_API_KEY={your_api_key}` 형식으로 API 키를 저장합니다. (실제 사용 시 `{your_api_key}` 부분을 본인의 키로 바꿔야 합니다.)
- **셀 4 (Code):**
    - `.env` 파일에서 API 키를 로드하려고 시도합니다.
    - 하지만 `load_dotenv(base_path + ".env")`와 같이 파일 경로가 잘못 지정되어(예: `.../09_RAG.env`) **출력(Output)**을 보면 `ERROR`가 발생합니다.
- **셀 5 (Code):**
    - 4번 셀의 오류를 수정한 코드입니다. `os.path.join(base_path, ".env")`를 사용해 올바른 경로(예: `.../09_RAG/.env`)를 지정합니다.
    - `load_dotenv`로 `.env` 파일을 성공적으로 로드하고 `UPSTAGE_API_KEY` 변수에 키를 저장합니다.
    - *출력(Output)**에 `Success API Key Setting!`이 표시되어 성공을 확인합니다.
- **셀 6 (Code):**
    - `glob` 모듈을 사용해 `base_path`에서 `.pdf` 확장자를 가진 모든 파일 목록을 찾습니다.
    - *출력(Output)**을 통해 '예스24' 관련 서비스 혜택 PDF 파일 8개가 발견되었음을 보여줍니다.
- **셀 7 (Code):**
    - `%pip install --quiet` 명령어를 사용해 RAG 및 LangChain에 필요한 파이썬 라이브러리들을 설치합니다.
    - (예: `langchain-text-splitters`, `tiktoken`, `langchain-community`, `chromadb`, `langchain-upstage`, `pypdf` 등)

---

### 2. 청킹(Chunking) 및 파싱(Parsing) (8~12번 셀)

문서를 LLM이 처리하기 좋은 형태로 가공하는 '파싱'과 '청킹' 개념을 실습합니다.

- **셀 8 (Markdown):**
    - `# 청킹 & 파싱`
    - **파싱(Parsing)** (PDF, 웹 등 → 순수 텍스트), **청킹(Chunking)** (긴 텍스트 → LLM 컨텍스트 창 크기에 맞는 작은 조각), **토크나이징(Tokenizing)** (문장 → 의미 단위 토큰)의 개념을 설명합니다.
- **셀 9 (Code):**
    - `tiktoken` 라이브러리로 **토크나이징**을 시연합니다.
    - 예시 텍스트("AI 온라인 서점입니다...")가 198개의 문자인 반면, `cl100k_base` 인코더를 통과하면 167개의 토큰으로 변환됨을 보여줍니다.
- **셀 10 (Code):**
    - `RecursiveCharacterTextSplitter`를 사용해 **청킹**을 시연합니다.
    - `chunk_size`(청크 크기)와 `chunk_overlap`(겹침) 설정을 4가지로 다르게 하여 텍스트를 분할하고, 설정에 따라 청크 개수와 내용이 어떻게 달라지는지 비교합니다.
- **셀 11 (Code):**
    - `%%writefile` 매직 명령어를 사용해 `shipping_policy.txt`라는 텍스트 파일을 Colab 환경에 생성합니다. (내용: AI 온라인 서점 배송 정책)
- **셀 12 (Code):**
    - 11번 셀에서 만든 `shipping_policy.txt` 파일을 `TextLoader`로 불러옵니다(파싱).
    - `RecursiveCharacterTextSplitter` (크기 200, 겹침 20)를 사용해 이 텍스트를 분할합니다(청킹).
    - *출력(Output)**에서 1개의 원본 문서가 2개의 청크로 분할되었음을 확인합니다.

---

### 3. LangChain 기본 (13~14번 셀)

LangChain의 핵심 구성 요소인 LLM Chain을 실습합니다.

- **셀 13 (Markdown):**
    - `# LangChain` / `## LLM Chain`
    - LangChain과 LLM Chain(입력 → 프롬프트 → 모델 → 출력 처리)의 개념을 설명합니다.
- **셀 14 (Code):**
    - *LCEL(LangChain Expression Language)**을 사용해 간단한 LLM 체인을 구성합니다.
    - 
        1. `ChatUpstage` (LLM)를 정의합니다.
    - 
        1. `ChatPromptTemplate` (프롬프트)에 시스템 메시지("존댓말로 답변")와 'Few-shot' 예시(프랑스→파리, 일본→도쿄)를 설정합니다.
    - 
        1. `prompt | llm | StrOutputParser()` 형태로 체인을 정의합니다.
    - 
        1. 마지막 질문("그렇다면, 한국은?")을 `invoke`하여 실행합니다.
    - **출력(Output):** LLM이 프롬프트의 맥락을 이해하고 "알고 있습니다. 서울입니다."라고 정확히 답변합니다.

---

### 4. RAG 구축 (15~22번 셀)

RAG의 3단계(Indexing, Retrieval, Generation)를 코드로 구현합니다.

- **셀 15 (Markdown):**
    - `# RAG (Retrieval-Augmented Generation)`
    - RAG의 개념과 3가지 과정(Indexing, Retrieval, Generation)을 설명합니다.
- **셀 16 (Markdown):**
    - `## 1. Indexing (색인화)`
    - RAG의 첫 단계인 '색인화'와 'Vector Store & Embedding' 개념을 설명합니다.
- **셀 17 (Code):**
    - **Indexing(색인화)** 과정을 실행합니다.
    - 
        1. `UpstageEmbeddings` (임베딩 모델)을 로드합니다.
    - 
        1. 12번 셀에서 만든 2개의 `chunks`(배송 정책)를 임베딩 모델로 벡터화합니다.
    - 
        1. 이 벡터들을 `Chroma` (Vector Store)에 저장합니다.
    - **출력(Output):** 2개의 문서가 Vector Store에 저장되었음을 확인합니다.
- **셀 18 (Markdown):**
    - `### 1-2. Retriever (검색기)`
    - Vector Store에서 문서를 검색하는 'Retriever'를 설명합니다.
- **셀 19 (Code):**
    - **Retrieval(검색)** 과정을 시연합니다.
    - `query = "배송 정책 알려줘"`라는 질문으로 Vector Store에 저장된 문서를 검색합니다.
    - `similarity_search` (유사도 검색)와 `as_retriever().invoke` (Retriever로 검색) 두 가지 방식을 모두 실행하며, **출력(Output)**을 통해 두 방식 모두 배송 정책 문서를 성공적으로 찾아냈음을 보여줍니다.
- **셀 20 (Markdown):**
    - `## 2. Retrieval (검색)` / `## 3. Generation (생성)`
    - RAG의 두 번째, 세 번째 단계를 설명합니다. (19번 셀에서 검색을 했고, 이제 검색된 결과를 LLM에 넘겨 생성을 할 차례입니다.)
- **셀 21 (Code):**
    - **RAG(검색+생성) 체인**을 LCEL로 완성합니다.
    - 
        1. `rag_prompt_template`: LLM에게 `Context`(검색된 문서)를 기반으로 `Question`(질문)에 답하라는 프롬프트를 정의합니다.
    - 
        1. **RAG 체인:**
        - 질문이 들어오면 `retriever`가 문서를 검색(`Context` 생성)하고, 질문(`question`)과 함께 `rag_prompt`에 전달합니다.
        - 프롬프트가 완성되면 `llm`을 호출하고, 결과를 `StrOutputParser`로 출력합니다.
    - 
        1. **실행:** "배송 정책 알려줘"라고 질문합니다.
    - **출력(Output):** LLM이 Vector Store에서 검색된 **배송 정책 텍스트(Context)를 바탕으로** 상세한 답변을 생성합니다.
- **셀 22 (Code):**
    - 21번 셀의 RAG 체인에 **관련 없는 질문**("오늘 날씨 어때?")을 합니다.
    - **출력(Output):** `retriever`가 날씨 관련 문서를 찾지 못했으므로, LLM이 "제공된 문맥(Context)에는 날씨 정보가 없습니다"라고 정확하게 답변합니다. (RAG가 외부 지식이 아닌, 제공된 문서에 기반함을 보여줍니다.)

---

### 5. RAG 에이전트(Agent) 구축 (23~33번 셀)

스스로 생각하고 도구를 사용하여 RAG를 수행하는 '에이전트'를 만듭니다.

- **셀 23 (Markdown):**
    - `## RAG Agent`
    - 'RAG 에이전트' 섹션의 시작을 알리는 제목입니다.
- **셀 24 (Markdown):**
    - `### Agent Tool`
    - 에이전트가 사용할 '도구'에 대해 설명합니다.
- **셀 25 (Code):**
    - *첫 번째 도구 (Retriever Tool)**를 생성합니다.
    - `create_retriever_tool`을 사용해 19번 셀에서 만든 `retriever`를 '도구'로 만듭니다.
    - 이 도구의 이름은 `shipping_policy_search`로, "배송 정책 정보를 검색"하는 역할을 한다고 설명합니다.
    - 이 도구를 `agent_tools` 리스트에 추가합니다.
- **셀 26 (Code):**
    - *두 번째 도구 (Custom Tool)**를 생성합니다.
    - `@tool` 데코레이터를 사용해 `greet_customer` (고객 인사) 함수를 정의합니다.
    - 이 함수는 항상 "안녕하세요! AI 온라인 서점입니다..."라는 인사말을 반환합니다.
    - 이 도구 역시 `agent_tools` 리스트에 추가합니다.
- **셀 27 (Code):**
    - `agent_tools` 리스트를 출력하여, `shipping_policy_search`와 `greet_customer` 두 개의 도구가 준비되었음을 확인합니다.
- **셀 28 (Markdown):**
    - `### Agent Prompt`
    - 에이전트가 사용할 프롬프트를 설명합니다.
- **셀 29 (Code):**
    - `langchain.hub`에서 Upstage가 제공하는 한국어 ReAct 에이전트용 프롬프트(`upstage/react-agent-ko`)를 불러옵니다.
    - **출력(Output):** 에이전트가 'Thought(생각) → Action(행동) → Observation(관찰)'의 단계를 거치도록 지시하는 복잡한 프롬프트 템플릿의 내용이 표시됩니다.
- **셀 30 (Markdown):**
    - `### Agent Executor`
    - 에이전트를 실제로 실행하는 'Executor'를 설명합니다.
- **셀 31 (Code):**
    - *에이전트 실행기(Agent Executor)**를 생성합니다.
    - `create_react_agent` 함수를 사용해 LLM(14번 셀), Tools(27번 셀), Prompt(29번 셀)를 결합하여 에이전트 로직을 만듭니다.
    - `AgentExecutor`로 이 에이전트를 감싸 실제 실행할 수 있게 만듭니다. (`verbose=True`는 에이전트의 모든 생각/행동 과정을 출력하라는 설정입니다.)
- **셀 32 (Code):**
    - 에이전트에게 "안녕하세요"라고 질문합니다.
    - **출력(Output):** 에이전트가 `Thought`(생각)를 통해 이 질문이 인사말임을 인지하고, `Action`(행동)으로 `greet_customer` 도구를 호출합니다.
    - 도구의 `Observation`(관찰) 결과를 바탕으로 최종 답변을 생성합니다: "안녕하세요! AI 온라인 서점입니다..."
- **셀 33 (Code):**
    - 에이전트에게 "배송 정책 알려줄래?"라고 질문합니다.
    - **출력(Output):** 에이전트가 `Thought`(생각)를 통해 배송 정책 정보가 필요함을 인지하고, `Action`(행동)으로 `shipping_policy_search` 도구를 호출합니다.
    - Vector Store에서 검색된 `Observation`(관찰) 결과를 바탕으로, LLM이 배송 정책을 요약하여 최종 답변을 생성합니다.